### Quickfix

Electronic repair shop

### Installation

You can install this app using the [bench](https://github.com/frappe/bench) CLI:

```bash
cd $PATH_TO_YOUR_BENCH
bench get-app $URL_OF_THIS_REPO --branch version-16
bench install-app quickfix
```

### Contributing

This app uses `pre-commit` for code formatting and linting. Please [install pre-commit](https://pre-commit.com/#installation) and enable it for this repository:

```bash
cd apps/quickfix
pre-commit install
```

Pre-commit is configured to use the following tools for checking and formatting your code:

- ruff
- eslint
- prettier
- pyupgrade

### Contribution Files Explanation

site_config.json is used for site-specific settings like database credentials and developer mode, whereas common_site_config.json stores global configurations shared across all sites in the bench like the database host. If a secret is accidentally placed in common_site_config.json, it becomes accessible to every site on that bench regardless of its environment. This creates a security risk where production sites might unintentionally leak sensitive data or inherit development-only credentials. Therefore, keeping secrets in the individual site_config.json ensures proper isolation and security for multi-tenant setups.

### Bench Processes
The bench start command launches the following four processes:

web: The web server handling browser requests.

worker: Executes background tasks and asynchronous jobs.

scheduler: Enqueues scheduled events and periodic tasks.

socketio: Provides real-time communication for notifications and updates.

### Background Jobs Impact:
If the worker process crashes, background jobs will remain in the "Queued" state in the database. No background tasks—such as sending emails or processing long reports—will be executed until the worker is restarted.

### B1 - Tracce a Request End-to-End

Step - 1 : 
Q1 : When a browser hits /api/method/quickfix.api.get_job_summary, the get_job_summary() function in python handles this request. It must have a @frappe.whitelist function.

Frappe handles like - Browser sends the request to nginx. Nginx receives it and send to gunicorn. Gunicorn passes to frappe. Frappe sees a url starts with api/method then it sends request to handler.py and frappe reads quickfix.api.get_job_summary. It import the function and runs it.

Q2 : 
1./api/method/ - Calls your custom Python function which needs @frappe.whitelist()
2./api/resource/ - Uses built-in REST API and no whitelist needed

Q3 : When the browser hits /track-job, Frappe treats it as a website route and handles it through frappe/website/serve.py.

Step - 2 :
Q1 : The X-Frappe-CSRF-Token is generated by Frappe when a user logs in and is linked to the current session. It is automatically sent in POST requests for security. If it is omitted frappe will reject the request with 403 error.

Q2 : frappe.session.data contains information about the current logged-in user such as user ID, session ID, IP address, and login details.It helps Frappe identify and manage the active user session.

Step - 3 : Developer mode - It controls how error are shown. It 1 it shows the traceback, error in which line, file name, error type. But if it is 0 it generally shows "Internal Error". It prevents exposing our internal code. 

Where do production errors go? Production errors are stored in the Error Log DocType and log files inside the logs/ folder

Step - 4 : Frappe raises a PermissionError if the user does not have access to the document. The request stops at the ORM permission check layer before the document is returned to the whitelisted method.

### CI

This app can use GitHub Actions for CI. The following workflows are configured:

- CI: Installs this app and runs unit tests on every push to `develop` branch.
- Linters: Runs [Frappe Semgrep Rules](https://github.com/frappe/semgrep-rules) and [pip-audit](https://pypi.org/project/pip-audit/) on every pull request.


### License

mit
