### B1 - Trace a Request End-to-End

Step - 1 : 
Q1 : When a browser hits /api/method/quickfix.api.get_job_summary, the get_job_summary() function in python handles this request. It must have a @frappe.whitelist function.

Frappe handles like - Browser sends the request to nginx. Nginx receives it and send to gunicorn. Gunicorn passes to frappe. Frappe sees a url starts with api/method then it sends request to handler.py and frappe reads quickfix.api.get_job_summary. It import the function and runs it.

Q2 : 
1./api/method/ - Calls your custom Python function which needs @frappe.whitelist()
2./api/resource/ - Uses built-in REST API and no whitelist needed

Q3 : When the browser hits /track-job, Frappe treats it as a website route and handles it through frappe/website/serve.py.

Step - 2 :
Q1 : The X-Frappe-CSRF-Token is generated by Frappe when a user logs in and is linked to the current session. It is automatically sent in POST requests for security. If it is omitted frappe will reject the request with 403 error.

Q2 : frappe.session.data contains information about the current logged-in user such as user ID, session ID, IP address, and login details.It helps Frappe identify and manage the active user session.

Step - 3 : Developer mode - It controls how error are shown. It 1 it shows the traceback, error in which line, file name, error type. But if it is 0 it generally shows "Internal Error". It prevents exposing our internal code. 

Where do production errors go? Production errors are stored in the Error Log DocType and log files inside the logs/ folder

Step - 4 : Frappe raises a PermissionError if the user does not have access to the document. The request stops at the ORM permission check layer before the document is returned to the whitelisted method.


### B2 - ORM Internals & Query Builder

Part - A :
Q1 : The output shows the tables like tabJob Card, tabScheduled Job Log, tabScheduled Job Type. Frappe adds tab prefix to all DocType tables to distinguish them from system tables and follow a consistent naming convention.

Q2 : Name, Creation, Modified, Modified by, Owner

Part - D :
Q1 : 0 - Draft, 1 - Submitted, 2 - Cancelled

Q2 : We cannot normally call doc.save() on a submitted document because it is locked after submission. We also cannot call doc.submit() on a cancelled document; we must amend it to create a new draft before submitting again.

Q3 : This error occurs when another user has updated the document after you opened it. Frappe compares the modified timestamp and prevents concurrent overwriting.

Part - E :
Bug 1 - Calling self.save() inside validate() causes recursive save calls and breaks the document lifecycle. Lifecycle hooks should not manually call save().
Bug 2 - Updating stock inside validate() modifies data before the document is officially submitted. Stock changes should happen in on_submit() to maintain proper document lifecycle control.
Code : def validate(self):
            self.total = sum(r.amount for r in self.items)
        def on_submit(self):
            other = frappe.get_doc("Spare Part", self.part)
            other.stock_qty -= self.qty
            other.save()

### C1 - Child Table Internals
Q1 : Automatic Columns: When a row is appended to a child table and saved, Frappe automatically populates four key system columns to maintain the relationship and order: 
1.parent
2.parentfield
3.parenttype
4.idx

Q2 : The DB table name for the Part Usage Entry DocType is tabPart Usage Entry

Q3 : If a row at idx=2 is deleted and the parent document is re-saved, Frappe automatically re-calculates the idx values for all remaining rows to maintain the sequence (continuous series of integers).

### C3 - Renaming Task
Q1 : Link field stores the document name (primary key) of the linked document. The renamed document will update automatically because frappe maintains link integrity at database level.
Track Changes means:
Frappe stores modification history of field values. Changes are visible in the document timeline. We can see the Old value, New value, Who changed it, When it was changed

Q2 : Unique - Database level unique index is created when we set setting unique for a feild. Even if we skip the validations the DB will reject duplicates.

    frappe.db.exists() - Checks manually before saving the document and it is application-level validation. It can be bypassed if logic is removed.

### D1 - Roles, Permissions Matrix and Document Sharing

Q1 : frappe.only_for("QF Manager") restricts the method to users having the QF Manager role. If a non-manager calls the method, Frappe raises a PermissionError and stops execution, returning a 403 Not Permitted response.

Q2 : {'if_owner': {},
 'has_if_owner_enabled': False,
 'select': 0,
 'read': 1,
 'write': 1,
 'create': 0,
 'delete': 0,
 'submit': 1,
 'cancel': 0,
 'amend': 0,
 'print': 0,
 'email': 0,
 'report': 0,
 'import': 0,
 'export': 0,
 'share': 0}
Logged in as Technician

### D2 - Permission Query & has_permission
Using frappe.get_all() in an whitelist method wont check the frappe's permission system, including permission_query_conditions. This means low-privilege users or guests can access records they are not supposed to see. It can cause serious data leakage.

### E1 - Complete Job Card Lifecycle
Calling self.save() inside on_update() causes infinite recursion because save() triggers on_update() again. This results in a recursion error. The correct approach is to use self.db_set() or move the logic to validate() to avoid triggering the lifecycle repeatedly.

